<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Модель Металлоконструкций Этажерки</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #e0f7fa, #bbdefb);
            color: #333;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            width: 100%;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        h1 {
            color: #1565c0;
            margin-bottom: 10px;
            font-size: 2.5rem;
        }
        
        .subtitle {
            color: #5d99c6;
            font-size: 1.2rem;
        }
        
        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            width: 100%;
            justify-content: center;
        }
        
        .model-container {
            flex: 1;
            min-width: 600px;
            height: 500px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        
        #structure-container {
            width: 100%;
            height: 100%;
        }
        
        .controls {
            flex: 0 0 350px;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        h2 {
            color: #1565c0;
            border-bottom: 2px solid #1565c0;
            padding-bottom: 8px;
            margin-bottom: 15px;
        }
        
        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .slider-value {
            font-weight: bold;
            color: #1565c0;
        }
        
        input[type="range"] {
            width: 100%;
            height: 10px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, #1565c0, #42a5f5);
            border-radius: 5px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            border: 2px solid #1565c0;
        }
        /*
        .slider-ticks {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #5d99c6;
            margin-top: 5px;
        }
        */
        /*
        .dimensions-display {
            margin-top: 15px;
            padding: 15px;
            background-color: rgba(237, 245, 255, 0.8);
            border-radius: 10px;
            font-family: monospace;
        }
        
        .dimensions-display h3 {
            color: #1565c0;
            margin-bottom: 10px;
        }
        */
        .instructions {
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            width: 100%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .instructions h2 {
            margin-bottom: 15px;
        }
        
        .instructions ul {
            padding-left: 20px;
            line-height: 1.6;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }
        
        .instructions code {
            background-color: rgba(237, 245, 255, 0.8);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }
        
        .footer {
            margin-top: 30px;
            color: #5d99c6;
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        @media (max-width: 1000px) {
            .content {
                flex-direction: column;
                align-items: center;
            }
            
            .model-container, .controls {
                width: 100%;
                min-width: unset;
            }
            
            .model-container {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!--
        <header>
            <h1>3D Модель Металлоконструкций Этажерки</h1>
            <p class="subtitle">Интерактивная модель с крестообразными раскосами и оборудованием на ярусах</p>
        </header>
        -->
        
        <div class="content">
            <div class="model-container">
                <div id="structure-container"></div>
            </div>
            
            <div class="controls">
                <h2>Управление моделью</h2>
                
                <div class="control-group">
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Количество ярусов:</span>
                            <span id="floor-value" class="slider-value">3</span>
                        </div>
                        <input type="range" id="floor-slider" min="1" max="6" value="3" step="1">
                        <!--
                        <div class="slider-ticks">
                            <span>1</span>
                            <span>2</span>
                            <span>3</span>
                            <span>4</span>
                            <span>5</span>
                            <span>6</span>
                        </div>
                        -->
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Высота яруса (м):</span>
                            <span id="height-value" class="slider-value">3.0</span>
                        </div>
                        <input type="range" id="height-slider" min="2.0" max="5.0" value="3.0" step="0.5">
                        <!--
                        <div class="slider-ticks">
                            <span>2.0</span>
                            <span>5.0</span>
                        </div>
                        -->
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Количество оборудования:</span>
                            <span id="equipment-value" class="slider-value">3</span>
                        </div>
                        <input type="range" id="equipment-slider" min="1" max="6" value="3" step="1">
                        <!--
                        <div class="slider-ticks">
                            <span>Меньше</span>
                            <span>Больше</span>
                        </div>
                        -->
                    </div>
                </div>
                
                <!--
                <div class="control-group">
                    <h3>Управление вращением</h3>
                    <p>• Перетаскивайте мышью для вращения модели</p>
                    <p>• Используйте колёсико мыши для приближения/отдаления</p>
                </div>
                
                <div class="dimensions-display">
                    <h3>Габаритные размеры:</h3>
                    <div id="dimensions-text">Длина: 12.0 м, Ширина: 8.0 м, Высота: 9.0 м</div>
                    <div id="elements-count">Колонн: 8, Раскосов: 48, Ярусов: 3</div>
                </div>
                -->
            </div>
        </div>
        
        <!--
        <div class="instructions">
            <h2>Технические характеристики модели</h2>
            <ul>
                <li><strong>Колонны</strong>: Двутавровый профиль высотой 300 мм</li>
                <li><strong>Раскосы</strong>: Крестообразные раскосы из уголков 100×100×10 мм</li>
                <li><strong>Ригели</strong>: Двутавровый профиль высотой 200 мм</li>
                <li><strong>Полы ярусов</strong>: Решётчатый настил с условным оборудованием</li>
                <li><strong>Оборудование</strong>: Цистерны, трубы, насосы, шаровые ёмкости</li>
                <li><strong>Основание</strong>: Железобетонная плита с размерами</li>
            </ul>
        </div>
        
        <div class="footer">
            <p>Разработано с использованием THREE.js | Модель металлоконструкций этажерки</p>
        </div>
        -->
    </div>

    <!-- THREE.js библиотеки -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    
    <script>
        // Основные переменные
        let scene, camera, renderer, controls, font;
        let structure = new THREE.Group();
        let floorCount = 3;
        let tierHeight = 3.0;
        let equipmentCount = 3;
        const structureLength = 12.0;
        const structureWidth = 8.0;
        
        // Материалы (более светлые)
        const materials = {
            column: new THREE.MeshStandardMaterial({ 
                color: 0x5d9cec, // светлый синий
                metalness: 0.6,
                roughness: 0.3
            }),
            diagonal: new THREE.MeshStandardMaterial({ 
                color: 0xff9800, // оранжевый
                metalness: 0.5,
                roughness: 0.4
            }),
            beam: new THREE.MeshStandardMaterial({ 
                color: 0x90a4ae, // светлый серый
                metalness: 0.6,
                roughness: 0.3
            }),
            base: new THREE.MeshStandardMaterial({ 
                color: 0xb0bec5, // светлый серый
                metalness: 0.2,
                roughness: 0.8
            }),
            floor: new THREE.MeshStandardMaterial({ 
                color: 0x78909c, // серо-голубой
                metalness: 0.3,
                roughness: 0.7,
                transparent: true,
                opacity: 0.7
            }),
            equipment1: new THREE.MeshStandardMaterial({ 
                color: 0xf44336, // красный
                metalness: 0.4,
                roughness: 0.5
            }),
            equipment2: new THREE.MeshStandardMaterial({ 
                color: 0x4caf50, // зелёный
                metalness: 0.4,
                roughness: 0.5
            }),
            equipment3: new THREE.MeshStandardMaterial({ 
                color: 0xffeb3b, // жёлтый
                metalness: 0.4,
                roughness: 0.5
            }),
            pipe: new THREE.MeshStandardMaterial({ 
                color: 0x607d8b, // серо-голубой
                metalness: 0.7,
                roughness: 0.3
            })
        };
        
        // Загрузка шрифта для 3D текста
        const fontLoader = new THREE.FontLoader();
        
        // Инициализация сцены
        function init() {
            // Создание сцены (светлый фон)
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f7fa);
            
            // Создание камеры
            camera = new THREE.PerspectiveCamera(45, 600 / 500, 0.1, 1000);
            camera.position.set(20, 15, 20);
            
            // Создание рендерера
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(600, 500);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0xf5f7fa);
            
            // Добавление рендерера в DOM
            const container = document.getElementById('structure-container');
            container.appendChild(renderer.domElement);
            
            // Добавление управления орбитальной камерой
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI / 2;
            
            // Загрузка шрифта и создание сцены
            fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(loadedFont) {
                font = loadedFont;
                // Добавление освещения
                addLighting();
                
                // Создание ландшафта
                createLandscape();
                
                // Создание конструкции
                createStructure();
                
                // Анимация
                animate();
            });
            
            // Добавление обработчиков событий для слайдеров
            document.getElementById('floor-slider').addEventListener('input', updateFloorCount);
            document.getElementById('height-slider').addEventListener('input', updateTierHeight);
            document.getElementById('equipment-slider').addEventListener('input', updateEquipmentCount);
        }
        
        // Добавление освещения (ярче)
        function addLighting() {
            // Основной направленный свет
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(15, 25, 15);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Заполняющий свет
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            
            // Свет снизу для подчеркивания структуры
            const bottomLight = new THREE.HemisphereLight(0xa0c8ff, 0x6688cc, 0.4);
            scene.add(bottomLight);
        }
        
        // Создание ландшафта
        function createLandscape() {
            // Основание (железобетонная плита)
            const baseGeometry = new THREE.BoxGeometry(structureLength + 4, 0.5, structureWidth + 4);
            const base = new THREE.Mesh(baseGeometry, materials.base);
            base.position.y = -0.25;
            base.receiveShadow = true;
            scene.add(base);
            
            // Разметочная сетка на основании
            createGridOnBase();
            
            // Добавляем размерные надписи
            createDimensionLabels();
        }
        
        // Создание разметочной сетки
        function createGridOnBase() {
            const gridSize = Math.max(structureLength, structureWidth) + 4;
            const divisions = 10;
            const gridHelper = new THREE.GridHelper(gridSize, divisions, 0xaaaaaa, 0xdddddd);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);
        }
        
        // Создание размерных надписей
        function createDimensionLabels() {
            if (!font) return;
            
            const textOptions = {
                font: font,
                size: 0.8,
                height: 0.1,
                curveSegments: 12,
                bevelEnabled: false
            };
            
            // Размер по длине
            const lengthText = `${structureLength.toFixed(1)} м`;
            const lengthGeometry = new THREE.TextGeometry(lengthText, textOptions);
            const lengthMaterial = new THREE.MeshBasicMaterial({ color: 0x1565c0 });
            const lengthMesh = new THREE.Mesh(lengthGeometry, lengthMaterial);
            
            // Центрируем геометрию текста
            lengthGeometry.computeBoundingBox();
            const lengthWidth = lengthGeometry.boundingBox.max.x - lengthGeometry.boundingBox.min.x;
            
            lengthMesh.position.set(-lengthWidth/2, 0.2, -structureWidth/2 - 2.5);
            lengthMesh.rotation.x = -Math.PI / 2;
            scene.add(lengthMesh);
            
            // Размер по ширине
            const widthText = `${structureWidth.toFixed(1)} м`;
            const widthGeometry = new THREE.TextGeometry(widthText, textOptions);
            const widthMaterial = new THREE.MeshBasicMaterial({ color: 0x1565c0 });
            const widthMesh = new THREE.Mesh(widthGeometry, widthMaterial);
            
            // Центрируем геометрию текста
            widthGeometry.computeBoundingBox();
            const widthTextWidth = widthGeometry.boundingBox.max.x - widthGeometry.boundingBox.min.x;
            
            widthMesh.position.set(-structureLength/2 - 2.5, 0.2, -widthTextWidth/2);
            widthMesh.rotation.x = -Math.PI / 2;
            widthMesh.rotation.z = Math.PI / 2;
            scene.add(widthMesh);
            
            // Размер по высоте (будет обновляться)
            updateHeightLabel();
        }
        
        // Обновление надписи высоты
        function updateHeightLabel() {
            // Удаляем старую надпись высоты, если есть
            const oldHeightLabel = scene.getObjectByName('heightLabel');
            if (oldHeightLabel) {
                scene.remove(oldHeightLabel);
            }
            
            if (!font) return;
            
            const totalHeight = floorCount * tierHeight;
            const heightText = `Высота: ${totalHeight.toFixed(1)} м`;
            
            const textOptions = {
                font: font,
                size: 0.8,
                height: 0.1,
                curveSegments: 12,
                bevelEnabled: false
            };
            
            const heightGeometry = new THREE.TextGeometry(heightText, textOptions);
            const heightMaterial = new THREE.MeshBasicMaterial({ color: 0xff9800 });
            const heightMesh = new THREE.Mesh(heightGeometry, heightMaterial);
            heightMesh.name = 'heightLabel';
            
            // Центрируем геометрию текста
            heightGeometry.computeBoundingBox();
            const textWidth = heightGeometry.boundingBox.max.x - heightGeometry.boundingBox.min.x;
            
            heightMesh.position.set(structureLength/2 + 2, totalHeight/2, 0);
            scene.add(heightMesh);
            
            // Обновляем текст в панели управления
           // document.getElementById('dimensions-text').textContent = 
           //     `Длина: ${structureLength.toFixed(1)} м, Ширина: ${structureWidth.toFixed(1)} м, Высота: ${totalHeight.toFixed(1)} м`;
        }
        
        // Создание двутавровой колонны
        function createIBeamColumn(x, z, height) {
            const columnGroup = new THREE.Group();
            
            // Основная стенка
            const webGeometry = new THREE.BoxGeometry(0.3, height, 0.01);
            const web = new THREE.Mesh(webGeometry, materials.column);
            web.castShadow = true;
            columnGroup.add(web);
            
            // Верхняя полка
            const topFlangeGeometry = new THREE.BoxGeometry(0.01, height, 0.3);
            const topFlange = new THREE.Mesh(topFlangeGeometry, materials.column);
            topFlange.position.y = 0;
            topFlange.position.x = 0.15;
            topFlange.castShadow = true;
            columnGroup.add(topFlange);
            
            // Нижняя полка
            const bottomFlange = new THREE.Mesh(topFlangeGeometry, materials.column);
            bottomFlange.position.y = 0;
            bottomFlange.position.x = -0.15;
            bottomFlange.castShadow = true;
            columnGroup.add(bottomFlange);
            
            columnGroup.position.set(x, height/2, z);
            return columnGroup;
        }
        
        // Создание крестообразного раскоса
        function createCrossDiagonal(x1, z1, x2, z2, yPos, height) {
            const diagonalGroup = new THREE.Group();
            
            // Вычисляем длину диагонали
            const dx = x2 - x1;
            const dz = z2 - z1;
            const length = Math.sqrt(dx*dx + dz*dz);
            
            // Первый диагональный элемент (основной)
            const diag1Geometry = new THREE.BoxGeometry(0.08, height, 0.08);
            const diag1 = new THREE.Mesh(diag1Geometry, materials.diagonal);
            diag1.castShadow = true;
            
            // Второй диагональный элемент (крест-накрест)
            const diag2 = new THREE.Mesh(diag1Geometry, materials.diagonal);
            diag2.castShadow = true;
            diag2.rotation.y = Math.PI / 2;
            
            // Позиционируем группу
            diagonalGroup.add(diag1);
            diagonalGroup.add(diag2);
            
            diagonalGroup.position.set(
                (x1 + x2) / 2,
                yPos,
                (z1 + z2) / 2
            );
            
            // Поворачиваем по направлению диагонали
            const angle = Math.atan2(dz, dx);
            diagonalGroup.rotation.y = angle;
            
            return diagonalGroup;
        }
        
        // Создание пола яруса
        function createFloor(level, yPos) {
            const floorGroup = new THREE.Group();
            
            // Решётчатый настил
            const floorSizeX = structureLength - 1;
            const floorSizeZ = structureWidth - 1;
            
            // Основная решётка
            for (let i = 0; i <= 10; i++) {
                // Продольные элементы
                const beamXGeometry = new THREE.BoxGeometry(floorSizeX, 0.05, 0.05);
                const beamX = new THREE.Mesh(beamXGeometry, materials.floor);
                beamX.position.set(0, yPos + 0.025, -floorSizeZ/2 + i * floorSizeZ/10);
                beamX.castShadow = true;
                floorGroup.add(beamX);
                
                // Поперечные элементы
                const beamZGeometry = new THREE.BoxGeometry(0.05, 0.05, floorSizeZ);
                const beamZ = new THREE.Mesh(beamZGeometry, materials.floor);
                beamZ.position.set(-floorSizeX/2 + i * floorSizeX/10, yPos + 0.025, 0);
                beamZ.castShadow = true;
                floorGroup.add(beamZ);
            }
            
            return floorGroup;
        }
        
        // Создание оборудования на ярусе
        function createEquipment(level, yPos) {
            const equipmentGroup = new THREE.Group();
            
            // Количество оборудования в зависимости от настройки
            const count = Math.min(equipmentCount, 6);
            
            // Различные типы оборудования
            for (let i = 0; i < count; i++) {
                const type = i % 3;
                let equipment;
                
                switch(type) {
                    case 0: // Цистерна (цилиндр)
                        const tankGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.2, 16);
                        equipment = new THREE.Mesh(tankGeometry, materials.equipment1);
                        equipment.position.set(
                            -structureLength/3 + (i % 3) * structureLength/3,
                            yPos + 0.6,
                            -structureWidth/4 + Math.floor(i/3) * structureWidth/2
                        );
                        break;
                        
                    case 1: // Шаровая ёмкость
                        const sphereGeometry = new THREE.SphereGeometry(0.6, 16, 16);
                        equipment = new THREE.Mesh(sphereGeometry, materials.equipment2);
                        equipment.position.set(
                            -structureLength/4 + (i % 3) * structureLength/4,
                            yPos + 0.6,
                            -structureWidth/3 + Math.floor(i/3) * structureWidth/3
                        );
                        break;
                        
                    case 2: // Кубический резервуар
                        const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
                        equipment = new THREE.Mesh(cubeGeometry, materials.equipment3);
                        equipment.position.set(
                            -structureLength/3 + (i % 3) * structureLength/3,
                            yPos + 0.5,
                            structureWidth/4 - Math.floor(i/3) * structureWidth/2
                        );
                        break;
                }
                
                equipment.castShadow = true;
                equipmentGroup.add(equipment);
                
                // Добавляем трубы к оборудованию
                if (i > 0) {
                    const prevEquipment = equipmentGroup.children[i-1];
                    if (prevEquipment) {
                        const pipe = createPipe(
                            prevEquipment.position.x, prevEquipment.position.y, prevEquipment.position.z,
                            equipment.position.x, equipment.position.y, equipment.position.z
                        );
                        equipmentGroup.add(pipe);
                    }
                }
            }
            
            return equipmentGroup;
        }
        
        // Создание трубы
        function createPipe(x1, y1, z1, x2, y2, z2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const dz = z2 - z1;
            const length = Math.sqrt(dx*dx + dy*dy + dz*dz);
            
            const pipeGeometry = new THREE.CylinderGeometry(0.05, 0.05, length, 8);
            const pipe = new THREE.Mesh(pipeGeometry, materials.pipe);
            pipe.castShadow = true;
            
            // Позиционируем и поворачиваем трубу
            pipe.position.set(
                (x1 + x2) / 2,
                (y1 + y2) / 2,
                (z1 + z2) / 2
            );
            
            // Вычисляем угол поворота
            pipe.rotation.x = Math.atan2(dz, Math.sqrt(dx*dx + dy*dy));
            pipe.rotation.z = Math.atan2(dy, dx);
            
            return pipe;
        }
        
        // Создание ригеля (горизонтальной балки)
        function createBeam(startX, startZ, endX, endZ, yPos) {
            const beamGroup = new THREE.Group();
            
            const dx = endX - startX;
            const dz = endZ - startZ;
            const length = Math.sqrt(dx*dx + dz*dz);
            
            // Основная стенка ригеля
            const webGeometry = new THREE.BoxGeometry(0.2, length, 0.008);
            const web = new THREE.Mesh(webGeometry, materials.beam);
            web.castShadow = true;
            
            // Верхняя полка
            const topFlangeGeometry = new THREE.BoxGeometry(0.008, length, 0.15);
            const topFlange = new THREE.Mesh(topFlangeGeometry, materials.beam);
            topFlange.position.x = 0.1;
            topFlange.castShadow = true;
            
            // Нижняя полка
            const bottomFlange = new THREE.Mesh(topFlangeGeometry, materials.beam);
            bottomFlange.position.x = -0.1;
            bottomFlange.castShadow = true;
            
            beamGroup.add(web);
            beamGroup.add(topFlange);
            beamGroup.add(bottomFlange);
            
            // Позиционируем и поворачиваем ригель
            beamGroup.position.set(
                (startX + endX) / 2,
                yPos,
                (startZ + endZ) / 2
            );
            
            const angle = Math.atan2(dz, dx);
            beamGroup.rotation.y = -angle;
            beamGroup.rotation.z = Math.PI / 2;
            
            return beamGroup;
        }
        
        // Создание конструкции
        function createStructure() {
            // Удаляем старую конструкцию
            if (structure) {
                scene.remove(structure);
            }
            
            structure = new THREE.Group();
            structure.name = 'steelStructure';
            
            // Позиции колонн (8 колонн - по 2 на каждой стороне)
            const columnPositions = [
                // Левая сторона (задняя и передняя)
                [-structureLength/2, 0, -structureWidth/2],
                [-structureLength/2, 0, structureWidth/2],
                
                // Передняя сторона
                [-structureLength/4, 0, -structureWidth/2],
                [structureLength/4, 0, -structureWidth/2],
                
                // Правая сторона
                [structureLength/2, 0, -structureWidth/2],
                [structureLength/2, 0, structureWidth/2],
                
                // Задняя сторона
                [-structureLength/4, 0, structureWidth/2],
                [structureLength/4, 0, structureWidth/2]
            ];
            
            // Создаем колонны
            const columns = [];
            const totalHeight = floorCount * tierHeight;
            
            columnPositions.forEach(pos => {
                const column = createIBeamColumn(pos[0], pos[2], totalHeight);
                structure.add(column);
                columns.push(column);
            });
            
            let diagonalCount = 0;
            
            // Создаем ярусы
            for (let floor = 0; floor < floorCount; floor++) {
                const currentY = floor * tierHeight;
                const nextY = (floor + 1) * tierHeight;
                
                // Горизонтальные ригели на уровне текущего яруса
                // По длине
                structure.add(createBeam(-structureLength/2, -structureWidth/2, structureLength/2, -structureWidth/2, currentY));
                structure.add(createBeam(-structureLength/2, structureWidth/2, structureLength/2, structureWidth/2, currentY));
                
                // По ширине
                structure.add(createBeam(-structureLength/2, -structureWidth/2, -structureLength/2, structureWidth/2, currentY));
                structure.add(createBeam(structureLength/2, -structureWidth/2, structureLength/2, structureWidth/2, currentY));
                
                // Крестообразные раскосы в вертикальных плоскостях
                if (floor < floorCount - 1) {
                    // Фасадные раскосы (передняя сторона)
                    structure.add(createCrossDiagonal(
                        -structureLength/2, -structureWidth/2,
                        structureLength/2, -structureWidth/2,
                        (currentY + nextY) / 2,
                        tierHeight
                    ));
                    diagonalCount += 2; // Крестообразный раскос считаем как 2 элемента
                    
                    // Боковые раскосы (левая сторона)
                    structure.add(createCrossDiagonal(
                        -structureLength/2, -structureWidth/2,
                        -structureLength/2, structureWidth/2,
                        (currentY + nextY) / 2,
                        tierHeight
                    ));
                    diagonalCount += 2;
                    
                    // Задние раскосы
                    structure.add(createCrossDiagonal(
                        -structureLength/2, structureWidth/2,
                        structureLength/2, structureWidth/2,
                        (currentY + nextY) / 2,
                        tierHeight
                    ));
                    diagonalCount += 2;
                    
                    // Правые боковые раскосы
                    structure.add(createCrossDiagonal(
                        structureLength/2, -structureWidth/2,
                        structureLength/2, structureWidth/2,
                        (currentY + nextY) / 2,
                        tierHeight
                    ));
                    diagonalCount += 2;
                    
                    // Диагональные связи в горизонтальной плоскости
                    structure.add(createCrossDiagonal(
                        -structureLength/2, -structureWidth/2,
                        structureLength/2, structureWidth/2,
                        currentY + tierHeight/2,
                        0.5
                    ));
                    diagonalCount += 2;
                    
                    structure.add(createCrossDiagonal(
                        structureLength/2, -structureWidth/2,
                        -structureLength/2, structureWidth/2,
                        currentY + tierHeight/2,
                        0.5
                    ));
                    diagonalCount += 2;
                }
                
                // Пол яруса (начиная со второго яруса)
                if (floor > 0) {
                    structure.add(createFloor(floor, currentY - 0.1));
                    
                    // Оборудование на ярусе
                    structure.add(createEquipment(floor, currentY));
                }
            }
            
            // Верхний пояс (на самом верху)
            const topY = totalHeight;
            structure.add(createBeam(-structureLength/2, -structureWidth/2, structureLength/2, -structureWidth/2, topY));
            structure.add(createBeam(-structureLength/2, structureWidth/2, structureLength/2, structureWidth/2, topY));
            structure.add(createBeam(-structureLength/2, -structureWidth/2, -structureLength/2, structureWidth/2, topY));
            structure.add(createBeam(structureLength/2, -structureWidth/2, structureLength/2, structureWidth/2, topY));
            
            scene.add(structure);
            
            // Обновляем счетчик элементов
            // document.getElementById('elements-count').textContent = 
            //    `Колонн: ${columns.length}, Раскосов: ${diagonalCount}, Ярусов: ${floorCount}`;
            
            // Обновляем надпись высоты
            updateHeightLabel();
        }
        
        // Обновление количества ярусов
        function updateFloorCount(event) {
            floorCount = parseInt(event.target.value);
            document.getElementById('floor-value').textContent = floorCount;
            createStructure();
        }
        
        // Обновление высоты яруса
        function updateTierHeight(event) {
            tierHeight = parseFloat(event.target.value);
            document.getElementById('height-value').textContent = tierHeight.toFixed(1);
            createStructure();
        }
        
        // Обновление количества оборудования
        function updateEquipmentCount(event) {
            equipmentCount = parseInt(event.target.value);
            document.getElementById('equipment-value').textContent = equipmentCount;
            createStructure();
        }
        
        // Анимация
        function animate() {
            requestAnimationFrame(animate);
            
            // Убрано автоматическое вращение - только ручное управление мышью
            
            // Обновление элементов управления
            controls.update();
            
            // Рендеринг сцены
            renderer.render(scene, camera);
        }
        
        // Обработка изменения размера окна
        window.addEventListener('resize', function() {
            const container = document.querySelector('.model-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });
        
        // Инициализация при загрузке страницы
        window.onload = init;
    </script>
</body>
</html>